import os
import osproc
import strutils
import net
import .. / utils / dnsutils

const
  sysResolvConf = "/etc/resolv.conf"
  bakResolvConf = "/etc/resolv.conf.bak"
  runResolvConf = "/run/resolvconf/resolv.conf"
  # dhcpResolvConf = "/run/resolvconf/interface/NetworkManager"
  tailResolvConf = "/etc/resolvconf/resolv.conf.d/tail"


proc showHelpCmd(cmd = "dnstool", keyword = "help", args = "", descr = "") =
  #[
    Make color for command syntax in help bannner
    Print them in help
    Syntax: <command> <keyword> <args> [<description>]
    command -> light green
    keyword -> red
    args (optional) -> yellow
    description (optional) -> blue
  ]#
  var cmdOutput = ""
  cmdOutput &= "\e[92m" & cmd & "\e[0m " # Green color for command
  cmdOutput &= "\e[91m" & keyword & "\e[0m " # Red color for keyword
  if args != "":
    cmdOutput &= "\e[93m" & args & "\e[0m "
  if descr != "":
    cmdOutput &= "[\e[94m" & descr & "\e[0m]"
  
  echo cmdOutput


proc banner() =
  stdout.write("DNS Tool: A CLI tool to change DNS settings quickly\n")
  stdout.write("Developer: Nong Hoang \"DmKnght\" Tu <dmknght@parrotsec.org>\n")
  stdout.write("Gitlab: https://nest.parrot.sh/packages/tools/anonsurf\n")
  stdout.write("License: GPL3\n\n")


proc showHelpDesc(keyword = "", descr = "") =
  #[
    Make color for description
    syntax:
      <keyword>: <description>
    keyword -> red
    description -> blue
  ]#
  var helpDesc = ""
  if keyword != "":
    helpDesc = "\e[91m" & keyword & "\e[0m: "
  helpDesc &= "\e[94m" & descr & "\e[0m"

  echo "  " & helpDesc


proc help() =
  banner()
  # let progName = getAppFileName()
  let progName = "dnstool"
  showHelpCmd(cmd = progName, keyword = "help | -h | --help", descr = "Show help banner")
  showHelpCmd(cmd = progName, keyword = "status", descr = "Show current system DNS")
  showHelpCmd(cmd = "sudo " & progName, keyword = "address", args = "<DNS servers>" , descr = "Set DNS servers") # TODO improve msg quality here
  showHelpCmd(cmd = "sudo " & progName, keyword = "create-backup", descr = "Make backup for current /etc/resolv.conf")
  showHelpCmd(cmd = "sudo " & progName, keyword = "restore-backup", descr = "Restore backup of /etc/resolv.conf")
  stdout.write("\nAddress could be:\n")
  showHelpDesc(keyword = "opennic", descr = "OpenNIC address[es]")
  showHelpDesc(keyword = "parrot", descr = "ParrotOS DNS address[es]")
  showHelpDesc(keyword = "dhcp", descr = "Address[es] of current DHCP client.")
  showHelpDesc(descr = "Any IPv4 or IPv6 address[es]")
  stdout.write("\nStatic and Dynamic:\n")
  showHelpDesc(keyword = "dynamic", descr = sysResolvConf & " is a symlink of " & runResolvConf)
  showHelpDesc(keyword = "static", descr = sysResolvConf & " is not a symlink and won't be changed after reboot.")
  stdout.write("\n")


proc printErr(msg: string) =
  # Print error with color red
  echo "[\e[31m!\e[0m] \e[31m", msg, "\e[0m"


proc getParrotDNS(): string =
  #[
    Use host command to automatically get ip from director.geo.parrot.sh
    FIXME get addresses when dns is empty
    TODO use native libs instead of using subprocess
  ]#
  try:
    let output = execProcess("/usr/bin/host director.geo.parrot.sh")
    var allIP = ""
    for line in output.split("\n"):
      if line.startsWith("director.geo.parrot.sh has "):
        allIP &= "nameserver " & line.split(" ")[^1] & "\n"
      else:
        discard
    return allIP
  except:
    printErr("Failed to get DNS addresses from Parrot selector server")
    return ""


proc getOpenNIC(): string =
  result = "nameserver 185.121.177.177\nnameserver 169.239.202.202\n"


# proc getDhcpDNS(): string =
#   return readFile(dhcpResolvConf) & "\n"


proc lnkResovConf() =
  #[
    Create a symlink of /etc/resolv.conf from
    /run/resolvconf/resolv.conf
    FIXME if the system has the 127.0.0.1 in runResolvConf
  ]#
  try:
    createSymlink(runResolvConf, sysResolvConf)
  except:
    printErr("Failed to create symlink from " & sysResolvConf)


proc writeTail(dnsAddr: string) =
  #[
    Create dyanmic resolv.conf
    Write tail
  ]#
  try:
    writeFile(tailResolvConf, dnsAddr)
  except:
    printErr("Failed to write addresses to Tail")


proc writeResolv(dnsAddr: string) =
  #[
    Create static resolv.conf
  ]#
  let banner = "# Static resolv.conf generated by DNSTool\n# Settings wont change after reboot\n"
  try:
    writeFile(sysResolvConf, banner & dnsAddr)
  except:
    printErr("Failed to create new resolv.conf")


proc makeDHCPDNS() =
  try:
    removeFile(sysResolvConf)
    writeTail("")
    lnkResovConf()
  except:
    printErr("Failed to generate DHCP addresses")


proc handleMakeDNS(dnsAddr: string) =
  if dnsAddr == "":
    stderr.write("[!] Address is empty. Skip!\n")
    return
  try:
    # Remove old resolv.conf
    removeFile(sysResolvConf)
    # Remove old addresses in tail
    writeTail("")
    writeResolv(dnsAddr)
  except:
    printErr("Failed to write settings to resolv.conf")


proc mkBackup() =
  #[
    Backup current settings of /etc/resolv.conf
    to /etc/resolv.conf.bak
  ]#
  # Check previous backup exists
  # Check current settings
  # skip if it is localhost or error of /etc/resolv.conf
  # or symlink
  let status = dnsStatusCheck()
  if status <= 0:
    # We are having error -> skip
    discard
  else:
    try:
      copyFile(sysResolvConf, bakResolvConf)
    except:
      printErr("Failed to create backup file for resolv.conf")


proc restoreBackup() =
  #[
    Restore /etc/resolv.conf.bak to /etc/resolv.conf
    Or use dhcp addresses
  ]#
  let status = dnsStatusCheck()
  if status == STT_DNS_TOR:
    # AnonSurf is running so it is using localhost. skip
    return
  if not fileExists(bakResolvConf):
    # No backup file. We create DHCP + dynamic setting
    # If there is no resolv.conf, we create symlink
    # If there is resolv.conf:
    # Create dhcp setting only DNS is localhost
    if fileExists(sysResolvConf):
      if status != ERROR_DNS_LOCALHOST:
        return
      makeDHCPDNS()
    else:
      lnkResovConf()
  else:
    # If resolv.conf not found, we force creating DHCP
    if status == ERROR_FILE_NOT_FOUND:
      makeDHCPDNS()
    # Else we have resolv.conf and its backup file
    else:
      # First force removing old resolv.conf
      # Solve the symlink error while writing new file
      if tryRemoveFile(sysResolvConf):
        moveFile(bakResolvConf, sysResolvConf)
      else:
        discard # TODO show error here


proc showStatus() =
  #[
    Get current settings of DNS on system
  ]#
  let statusResult = dnsStatusCheck()
  var
    dnsType = ""
    dnsAddr = ""

  case statusResult
  of STT_DNS_TOR:
    stdout.write("[\e[32mSTATUS\e[0m] AnonSurf DNS\n")
  of ERROR_DNS_LOCALHOST:
    stderr.write("[\e[31mERROR\e[0m] Local host\n")
  of ERROR_FILE_NOT_FOUND:
    stderr.write("[\e[31mERROR\e[0m] resolv.conf not found\n")
  of ERROR_FILE_EMPTY:
    stderr.write("[\e[31mERROR\e[0m] resolv.conf is empty\n")
  of ERROR_UNKNOWN:
    stderr.write("[\e[31mERROR\e[0m] Runtime error: Unknown problem\n")
  of 10 .. 13:
    dnsType = "Static"
  of 20 .. 23:
    dnsType = "Dynamic"
  else:
    discard
  
  case statusResult mod 10
  of 0:
    dnsAddr = "DHCP"
  of 1:
    dnsAddr = "OpenNIC"
  of 2:
    dnsAddr = "Custom"
  of 3:
    dnsAddr = "OpenNIC + Custom"
  else:
    discard

  if dnsType != "":
    echo "[\e[32mSTATUS\e[0m]\n- \e[31mMethod\e[0m: \e[36m" & dnsType & "\e[0m\n- \e[31mAddress\e[0m: \e[36m" & dnsAddr & "\e[0m"


proc main() =
  if paramCount() == 0:
    help()
    showStatus()
  elif paramCount() == 1:
    if paramStr(1) in ["help", "-h", "--help", "-help"]:
      help()
    elif paramStr(1) == "status":
      showStatus()
    elif paramStr(1) == "create-backup":
      mkBackup()
    elif paramStr(1) == "restore-backup":
      restoreBackup()
      showStatus()
    else:
      stderr.write("[!] Invalid option\n")
  else:
    if paramStr(1) == "address":
      if paramStr(2) == "dhcp":
        makeDHCPDNS()
      else:
        var
          dnsAddr = ""
        for i in 2 .. paramCount():
          if paramStr(i) == "opennic":
            dnsAddr &= getOpenNIC()
          elif paramStr(i) == "parrot":
            dnsAddr &= getParrotDNS()
          elif isIpAddress(paramStr(i)):
            dnsAddr &= "nameserver " & paramStr(i) & "\n"
        handleMakeDNS(dnsAddr)
      showStatus()
    else:
      help()
      stderr.write("[!] Invalid option\n")
      return    


main()
